---
title: "Check if a password is entered correctly - a tutorial"
author: "Kevin Trutmann, Nathaniel Phillips, Markus Steiner"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## About

This tutorial shows you how to implement a password check in a shiny app using the ShinyPsych package.

Sometimes you do not want everyone to participate in your study, but only some people who were invited e.g. by email. The password the participant enters will be hashed (encrypted) using the [SHA-512 algorithm](https://en.wikipedia.org/wiki/SHA-2) and checked against the version stored on the server which was hashed using the same algorithm. Therefore the password is never stored in plain text on the server.

In this tutorial, we will show you how to implement such a password check. Piece by piece we will go through the whole app code, with comments and explanations between the pieces. To see the app working, click [here]("inst/shiny-examples/CheckPassword/app.R"). In this app we will use a local text file containing the hashed password, which is stored in the app directory. For this reason you should make sure that the working directory is set to the app directory. You can achieve this with the `setwd('folder/name')` command. However, you could also load a textfile from dropbox if you want. To get your password hashed either use the `sha512()` function from the *openssl* package, or use an online tool such as [this one](https://hashgenerator.de/) (make sure to select the SHA-512 algorithm).

If you have any questions about the package, just email us at k.trutmann@gmail.com or markus.d.steiner@gmail.com. Now let's get started with the app...

## The Check Password App

We subdivided the script in eight sections:

* Section 0: Load Libraries
* Section A: Assign External Values
* Section B: Define Overall Layout
* Section C: Define Reactive Values
* Section D: Page Layouts
* Section F: Event (e.g. Button) Actions
* Section G: Create App


### Section 0: Load Libraries

```{r, eval=FALSE}
library(shiny)
library(shinyjs)
library(ShinyPsych)
```

This Survey app only relies on these three libraries (and their dependencies). The *shiny* library is, clue is in the name, the basis to create working shiny apps. It can be used to create html pages and dynamic interfaces, e.g. to display dynamic plots etc. *shinyjs* is a usefull tool to bring some javascript logic in the page, e.g. to control whether a button is disabled, i.e. nothing happens if you click it, and then to enable it, once e.g. a necessary input has been given. And *ShinyPsych* about which you'll learn more now...

### Section A: Assign External Values

```{r, eval=FALSE}
# Vector with page ids used to later access objects
idsVec <- c("Instructions", "Goodbye")

# create page lists for the instructions and the last page
instructions.list <- createPageList(fileName = "Instructions_CheckPassword",
                                    globId = "Instructions")
goodbye.list <- createPageList(fileName = "Goodbye")

```

First we define `idsVec`, which includes the identifying names of two page lists that contain the pages (such as displaying text or having survey questions on it) that we will use. You do not need to use these exact names, but whatever you call them here has to match what you call them at other occurences.

The `createPageList()` function that is called afterwards loads in .txt files whose names are given by the `fileName` argument. Thus, if `fileName = "Goodbye"`, R will search for a file named *Goodbye.txt* in the working directory, given it is not the name of a default list (in this case it is a default list). There are some default files, such as the two loaded in this tutorial. If you do **not** use a default list, make sure to set the `defaulttxt` argument of `createPageList()` to `FALSE`. If you have not stored your file in the app directory but, e.g. in the *www* folder of your app, make sure to also enter the path, e.g. `fileName = "www/Goodbye"`. Note that for the check passowrd instructions page list we added the argument `globId = "Instructions"` because the default id is just the `fileName`. This shortens the name of that page, and makes later code more readable.

The page lists we read in contain, among other things, the names of shiny functions and their arguments (for an in depth tutorial on this [click here](ShinyPsych_Textfiles.html "Set Up Survey Files")). These functions are then called to create the HTML logic needed to set up the pages. `createPageList()` then returns this HTML code, together with other things, as a list and saves it in the `instructions.list`. These HTML code snippets are then later used to display the respective pages.

Now all the lists are prepared and we go on to start defining the actual app.


### Section B: Define Overall Layout


```{r, eval=FALSE}
ui <- fixedPage(
  
  # App title
  title = "ShinyCheckPassword",
  uiOutput("MainAction"),
  
  # For Shinyjs functions
  useShinyjs(),
  
  # include appropriate css and js scripts
  includeScriptFiles()
  
)

server <- function(input, output, session) {
  
  output$MainAction <- renderUI( {
    PageLayouts()
    
  })


# The server function continues, which is why the curly brackets are not closed
```

The first part assigned to ui is the usual Shiny ui setup (if that's news for you, we recommend on reading up on Shiny apps first). The *title* will be displayed in the tab bar of the browser. `useShinyjs()` is needed to allow *shinyjs* functions to be used. `includeScriptFiles()` will include some of ShinyPsychs CSS and JavaScript scripts we've written for the tasks. Since we have no behavioral tasks in this app we don't need to specify additional arguments. If not otherwise specified with `globalScript = FALSE`, a CSS script will be loaded that specifies some parameters such as the font size. If you have additional own CSS or js files to include, you can do this with Shiny's `includeCSS()` and `includeScript()` functions. Note that all of our JavaScript scripts have two versions: a commented version that you can look at in the package directory to see what it's doing, and a compiled version (indicated by the *Comp.js* at the end of the filename), that was compiled using [Google's closure compiler](http://closure-compiler.appspot.com) to make it less readable. This is done to make it a bit harder for users to check or change the variables in the browser console. Please note the *session* in the server definition which is needed for the communication between the server-side Shiny and the user-side JavaScript.


### Section C: Define Reactive Values

```{r, eval=FALSE}
  # CurrentValues controls page setting such as which page to display
  CurrentValues <- createCtrlList(firstPage = "Instructions", # id of the first page
                                  globIds = idsVec,           # ids of pages for createPage
                                  complCode = TRUE,           # create a completion code
                                  complName = "EP-CheckPassword")   # first element of completion code
```

This function sets up the list of reactive values (again, if that's not a familiar term you should consider to read about Shiny apps first) needed to control settings and page navigation. `createCtrlList()` is used to set up the general control list that navigates you through the experiment by keeping track of things like the current page value. The `firstPage` argument indicates the id of the first page list to be loaded. The first page on this list will be the first thing you see when you run the app. `globIds` expects a vector containing all the ids of the page lists you want to use. We created such a vector earlier in section A and called it `idsVec`. `complCode` and `complName` control whether a completion code of the form "`complName`-XXX-XXX-XXX" should be generated, where XXX is a random number between 100 and 999. Such a code can be displayed to the participant in the end and can be used as proof of participation if needed.

### Section D: Page Layouts

```{r, eval=FALSE}

  PageLayouts <- reactive({
    
    # insert created completion code so it can later be displayed
    goodbye.list <- changePageVariable(pageList = goodbye.list,
                                       variable = "text",
                                       oldLabel = "completion.code",
                                       newLabel = CurrentValues$completion.code)
    
    # display instructions page
    if (CurrentValues$page == "Instructions") {
      
      return(
        # create html logic of instructions page
        createPage(pageList = instructions.list,
                   pageNumber = CurrentValues$Instructions.num,
                   globId = "Instructions",
                   ctrlVals = CurrentValues)
      )}
    
    # Goodbye page
    if (CurrentValues$page == "goodbye") {
      
      return(
        createPage(pageList = goodbye.list, pageNumber = CurrentValues$Goodbye.num,
                   globId = "Goodbye", ctrlVals = CurrentValues, continueButton = FALSE)
      )}
    
    # If the wrong password has been entered
    if (CurrentValues$page == "wrong password"){
      return(
        createWrongPasswordPage()
        )
    }    
  })
```

*PageLayouts* is a reactive expression in which the page layouts are defined. As you saw in section B it is rendered as a UI and through the `MainAction` variable of the `output` object it is passed to the used.

First, the *goodbye.list* is updated with the completion code. The default goodbye list contains a placeholder for the completion code that is changed using `changePageVariable()`. The pages are then created using the `createPage()` function by passing it the page lists  created in section A, the reactive control values created in section C and the global id, i.e. the respective id from *idsVec*. The *pageNumber* argument controls which page of the current list is to be displayed. You can see that the same is done with the Goodbye page, except that we are setting `continueButton`to `FALSE` since it will be the last page.

`createWrongPasswordPage()` can be used to create the page to be displayed in case the participant enters a wrong password. The page displays an information that the participant is not allowed to participate and a back button in case they just mistyped. This back button is also the reason why we don't use a page list in the form of a .txt file. As of yet it is not possible to implement more complex navigation in ShinyPsych. You could of course still create your own custom page. Just print the `createWrongPasswordPage` code to see how you could create a page and change it to your liking.
Then replace the `createWrongPasswordPage()` function call with the code you created.

### Section F: Event (e.g. Button) Actions

```{r, eval=FALSE}
  observeEvent(input[["Instructions_next"]],{
    nextPage(pageId = "Instructions", ctrlVals = CurrentValues, nextPageId = "goodbye",
             pageList = instructions.list, globId = "Instructions",
             checkAllowed = "password", checkAllowedPage = 1,
             checkIdVar = "pwInput", checkLocation = "local",
             checkFileName = "Password_Database.txt", checkNotAllowedId = "wrong password",
             inputList = input)
  })

  observeEvent(input[["wrongPWBack"]],{
    CurrentValues$Instructions.num <- 1
    CurrentValues$page = "Instructions"
  })
} # End of server function

```

The block observes a button named the same as the strings in the double brackets (here `Instructions_next`) and will, once it receives input from the observed button, call the function indicated in the curly brackets. The `nextPage()`function handles the flow through page lists created with `createPage()`. Each time the button is clicked, it will increase the page number of that page id by 1 until the maximum number of pages in that list is reached (for *Instructions* this maximum is 2) and will then go to the page list indicated at `nextPageId`. Compared to the other app tutorials that use this function, here we specify some additional arguments that all except inputList, which is the shiny input object, start with *check*. These arguments must be specified in order for the password to be checked (the `checkPassword()` function will be called for this). `checkAllowed` indicates whether an id check, a password check or no check should be executed (the default is "none"). `checkAllowedPage` indicates the page number in the current list (here `instructions.list`) after which you want to execute the check. Since the id is entered on page one we set this to 1, such that when you continue from page number 1 to 2 the check is executed. `checkIdVar` is the id of the password input element you want to check specified in the .txt file (without the globId name). `checkLocation` is the location of the hashed password/s (a csv file with one column and no header) is stored. This can be either *local*, *dropbox* or *vector*. If you choose the latter, you have to add the argument `checkIdsVec`, where you specify
a vector with hashed passwords. *checkFileName* is the database file name. *checkNotAllowedId* is the page list id of the (probably single-page) page list to be displayed if a wrong password is entered.


### Section G: Create App

```{r, eval=FALSE}
# Create app!
shinyApp(ui = ui, server = server)
```

The last step is to create the app.
